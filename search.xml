<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>csp练习</title>
    <url>/2022/03/10/csp%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="CCF202109-1-数组推导（100分）【序列处理】"><a href="#CCF202109-1-数组推导（100分）【序列处理】" class="headerlink" title="CCF202109-1 数组推导（100分）【序列处理】"></a>CCF202109-1 数组推导（100分）【序列处理】</h1><p><a href="https://tigerisland.blog.csdn.net/article/details/120533375">csdn地址</a><br>题目描述<br>A1,A2,…,An是一个由 n个自然数（即非负整数）组成的数组。在此基础上，我们用数组B1…Bn表示A的前缀最大值。<br>B i &#x3D; m a x { A 1 , A 2 , . . . , A i } Bi&#x3D;max{A1,A2,…,Ai}<br>Bi&#x3D;max{A1,A2,…,Ai}</p>
<p>如上所示，Bi定义为数组A中前i个数的最大值。<br>根据该定义易知A1&#x3D;B1，且随着i的增大，Bi单调不降。<br>此外，我们用sum&#x3D;A1+A2+…+An表示数组A中n个数的总和。</p>
<p>现已知数组B，我们想要根据B的值来反推数组A。<br>显然，对于给定的B，A的取值可能并不唯一。<br>试计算，在数组A所有可能的取值情况中，sum的最大值和最小值分别是多少？</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    <span class="type">int</span> last = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> summax=<span class="number">0</span>,summin=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);;</span><br><span class="line">        summax+=m;</span><br><span class="line">        <span class="keyword">if</span>(m!=last)&#123;</span><br><span class="line">            summin+=m;</span><br><span class="line">        &#125;</span><br><span class="line">        last = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;min = %d\nmax = %d&quot;</span>,summin,summax);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








]]></content>
  </entry>
  <entry>
    <title>LeetCode刷题-第二周</title>
    <url>/2022/03/07/LeetCode%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%BA%8C%E5%91%A8/</url>
    <content><![CDATA[<p>1、<br>(<a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">简单-876. 链表的中间结点</a>)给定一个头结点为 head 的非空单链表，返回链表的中间结点。<br>如果有两个中间结点，则返回第二个中间结点。<br>方法一、<br>思路：遍历一次整个链表得到结点数量，再遍历第二次得到中间节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">middleNode</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> *<span class="title">ListNode</span> <span class="title">result</span> =</span> head;</span><br><span class="line">    <span class="keyword">while</span>(ListNode-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt/<span class="number">2</span>+<span class="number">1</span>;i++)&#123;</span><br><span class="line">        result = result-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法二、<br>思路：快慢指针，快指针每次移动两个结点，慢指针每次移动一个结点，当快指针移动到尾部时慢指针正好指向链表中间结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">middleNode</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span>&#123;</span><br><span class="line">   <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">fast</span>=</span>head,*slow=head;</span><br><span class="line">   <span class="keyword">while</span>(fast!=<span class="literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">       fast = fast-&gt;next-&gt;next;</span><br><span class="line">       slow = slow-&gt;next;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<br>(<a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/">中等-19. 删除链表的倒数第 N 个结点</a>)给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。</p>
<p>思路：快慢指针，快指针比慢指针多移动n个结点，当快指针到达尾部的时候此时慢指针所指位置就是倒数第n个结点<br>注意：此处定义了一个哑结点，使函数可以不用判断是否为头结点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">removeNthFromEnd</span><span class="params">(<span class="keyword">struct</span> ListNode* head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">left</span>,*<span class="title">mid</span>,*<span class="title">right</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">dummy</span> =</span> (<span class="keyword">struct</span> ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> ListNode));</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    left = dummy;</span><br><span class="line">    left-&gt;next = head;</span><br><span class="line">    right = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        right = right-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(right!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        left = left-&gt;next;</span><br><span class="line">        right = right-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    left-&gt;next = left-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3、<br>(<a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">中等-3. 无重复字符的最长子串</a>)给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。字符串包含字母数字符号和空格<br>思路：定义两个指针，从左往右逐个移动，左指针和右指针中间的字串是没有重复字符的字串，使用数组定义一个int类型的空数组，根据字符的ascii码作为数组的坐标，若字符出现一次就将该坐标的值置为1。<br>注意：右指针不用每次都从左指针开始往右移动，因为左右指针中间部分是已经确定没有重复字符串的，只需要将左指针移动并将count计数变量值减一就行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;   <span class="type">int</span> statistic[<span class="number">95</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> left=<span class="number">-1</span>,right=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>,cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">if</span>(size==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(right&lt;size)</span><br><span class="line">    &#123;</span><br><span class="line">        left = left+<span class="number">1</span>;</span><br><span class="line">        cnt = cnt<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            c = s[right];</span><br><span class="line">            <span class="keyword">if</span>(statistic[c<span class="number">-32</span>]&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c \n&quot;</span>,c);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            statistic[c<span class="number">-32</span>] = statistic[c<span class="number">-32</span>]+<span class="number">1</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(right&lt;size);</span><br><span class="line">        statistic[s[left]<span class="number">-32</span>]--;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;max)&#123;</span><br><span class="line">            max = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql学习记录</title>
    <url>/2022/03/04/mysql%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="基本的SELECT语句"><a href="#基本的SELECT语句" class="headerlink" title="基本的SELECT语句"></a>基本的SELECT语句</h1><h2 id="特殊点"><a href="#特殊点" class="headerlink" title="特殊点"></a>特殊点</h2><p>SQL中字符串用’’,别名用””,字符串要区分大小写（但是这些在mysql由于不严谨，都不进行区分）</p>
<p>列的别名只能在order by 中使用，不能在where中进行使用</p>
<p>一旦给表取了别名，就必须使用别名，包括select后和where后</p>
<h2 id="列的别名"><a href="#列的别名" class="headerlink" title="列的别名"></a>列的别名</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 三种方式</span><br><span class="line"><span class="keyword">SELECT</span> empolyees_id emp_id, last_name <span class="keyword">AS</span> lname，department_id &quot;部门 id&quot; </span><br><span class="line">    <span class="keyword">FROM</span> employees; </span><br><span class="line"># 第三种方式不要使用单引号<span class="string">&#x27;&#x27;</span></span><br><span class="line"># 插入字符串的时候不要用双引号&quot;&quot;</span><br></pre></td></tr></table></figure>

<h2 id="去除重复行"><a href="#去除重复行" class="headerlink" title="去除重复行"></a>去除重复行</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 正确的</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> department_id <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> salary, department_id <span class="keyword">FROM</span> employees; # 不错，无意义（？）</span><br><span class="line"></span><br><span class="line"># 错误的</span><br><span class="line"><span class="keyword">SELECT</span> salary,<span class="keyword">DISTINCT</span> department_id <span class="keyword">FROM</span> employees; # 单独对部门id去重</span><br></pre></td></tr></table></figure>

<h2 id="空值参与运算"><a href="#空值参与运算" class="headerlink" title="空值参与运算"></a>空值参与运算</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">null</span> 不等同于<span class="number">0</span>，<span class="string">&#x27;&#x27;</span>，<span class="string">&#x27;null&#x27;</span></span><br><span class="line"># 任何<span class="keyword">null</span>参与的运算，最终结果都为<span class="keyword">null</span></span><br></pre></td></tr></table></figure>

<h2 id="着重号"><a href="#着重号" class="headerlink" title="着重号"></a>着重号</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">若表名是<span class="keyword">sql</span>关键字的时候，需要给表名加上着重号(`XXX`)</span><br></pre></td></tr></table></figure>

<h2 id="查询常数"><a href="#查询常数" class="headerlink" title="查询常数"></a>查询常数</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">&#x27;尚硅谷&#x27;</span>,empolyees_id <span class="keyword">FROM</span> employees; </span><br></pre></td></tr></table></figure>

<h2 id="显示表结构"><a href="#显示表结构" class="headerlink" title="显示表结构"></a>显示表结构</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> employees;</span><br><span class="line"><span class="keyword">DESC</span> employees;</span><br></pre></td></tr></table></figure>

<h2 id="数据过滤"><a href="#数据过滤" class="headerlink" title="数据过滤"></a>数据过滤</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employee <span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">90</span>;</span><br></pre></td></tr></table></figure>

<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="operator">+</span> <span class="operator">-</span> <span class="operator">*</span> <span class="operator">/</span> div <span class="operator">%</span> MOD</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span><span class="operator">+</span><span class="number">100</span> <span class="keyword">FROM</span> DUAL;   # DUAL 为伪表</span><br><span class="line"></span><br><span class="line"># 在<span class="keyword">SQL</span>中<span class="operator">+</span>没有连接的作用，就表示加法运算，此时会把字符串转换为数值类型（隐式转换）</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span><span class="operator">+</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">FROM</span> DUAL;   # <span class="number">101</span> 此时将<span class="string">&#x27;1&#x27;</span>看做<span class="number">1</span>处理</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span><span class="operator">+</span><span class="string">&#x27;a&#x27;</span> <span class="keyword">FROM</span> DUAL;   # <span class="number">100</span> 此时将<span class="string">&#x27;a&#x27;</span>看做<span class="number">0</span>处理</span><br><span class="line"></span><br><span class="line"># <span class="keyword">SQL</span>中 <span class="operator">/</span> 会默认转换为浮点型</span><br><span class="line"><span class="keyword">SELECT</span> <span class="number">100</span><span class="operator">/</span><span class="number">2</span> <span class="keyword">FROM</span> DUAL;    # <span class="number">50.000</span></span><br></pre></td></tr></table></figure>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>&#x3D; &lt;&#x3D;&gt; &lt;&gt; !&#x3D; &lt; &lt;&#x3D; &gt; &gt;&#x3D;<br>左边的数和右边的数进行比较，比较结果为真返回1，为假返回0，其余情况放回null    </p>
<h3 id="等号运算符（-x3D-）"><a href="#等号运算符（-x3D-）" class="headerlink" title="等号运算符（&#x3D;）"></a>等号运算符（&#x3D;）</h3><ul>
<li>若等号两边都是字符串，则按照ASCII码进行比较</li>
<li>若等号两边既有数字又有字符串，则将字符串转换为数字进行比较，若转换不成功将其看做0</li>
<li>若等号任意一边有null，则结果为null<h3 id="安全等与（-lt-x3D-gt-）"><a href="#安全等与（-lt-x3D-gt-）" class="headerlink" title="安全等与（&lt;&#x3D;&gt;）"></a>安全等与（&lt;&#x3D;&gt;）</h3></li>
<li>与等号运算符相等，但是能跟null进行比较，两边都是null返回1，一边null返回0<h3 id="非符号类型运算符"><a href="#非符号类型运算符" class="headerlink" title="非符号类型运算符"></a>非符号类型运算符</h3></li>
<li>ISNULL &#x2F; IS NOT NULL &#x2F; IS NULL</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> first_name,last_name,salary <span class="keyword">from</span> employees <span class="keyword">where</span> salary <span class="keyword">not</span> <span class="keyword">between</span> <span class="number">5000</span> <span class="keyword">and</span> <span class="number">12000</span>;</span><br><span class="line"><span class="keyword">select</span> first_name,last_name,department_id <span class="keyword">from</span> employees <span class="keyword">where</span> department_id<span class="operator">=</span><span class="number">50</span> <span class="keyword">or</span> department_id<span class="operator">=</span><span class="number">20</span>;</span><br><span class="line"><span class="keyword">select</span> first_name,last_name,department_id <span class="keyword">from</span> employees <span class="keyword">where</span> department_id<span class="operator">=</span><span class="number">50</span> <span class="keyword">or</span> department_id<span class="operator">=</span><span class="number">20</span>;</span><br><span class="line"><span class="keyword">select</span> first_name,last_name,salary,commission_pct <span class="keyword">from</span> employees <span class="keyword">where</span> commission_pct <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">select</span> first_name,last_name <span class="keyword">from</span> employees <span class="keyword">where</span> first_name <span class="keyword">like</span> <span class="string">&#x27;__a%&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> first_name,last_name <span class="keyword">from</span> employees <span class="keyword">where</span> first_name <span class="keyword">like</span> <span class="string">&#x27;%a%&#x27;</span> <span class="keyword">and</span> first_name <span class="keyword">like</span> <span class="string">&#x27;%k%&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> employees <span class="keyword">where</span> first_name <span class="keyword">like</span> <span class="string">&#x27;%e&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> department_id,job_id <span class="keyword">from</span> employees <span class="keyword">where</span> department_id <span class="keyword">between</span> <span class="number">80</span> <span class="keyword">and</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>LeetCode刷题-第一周</title>
    <url>/2022/03/03/LeetCode%E5%88%B7%E9%A2%98-%E7%AC%AC%E4%B8%80%E5%91%A8/</url>
    <content><![CDATA[<p>1、<br>(简单-704. 二分查找)给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> hight = numsSize<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low&lt;=hight)&#123;</span><br><span class="line">        <span class="type">int</span> mid = low+(hight-low)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            hight = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、<br>(简单-278. 第一个错误的版本)你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p>
<p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p>
<p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The API isBadVersion is defined for you.</span></span><br><span class="line"><span class="comment">// bool isBadVersion(int version);</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=n,c;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        c = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(isBadVersion(c))&#123;</span><br><span class="line">            r = c;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l = c+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、<br>(简单-35. 搜索插入位置)给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=numsSize<span class="number">-1</span>,c;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        c = l+(r-l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[c]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[c]&gt;target)&#123;</span><br><span class="line">            r = c<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l = c+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4、<br>(简单-977. 有序数组的平方)给你一个按 非递减顺序 排序（递增）的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。</p>
<p>思路：创建双指针，分别从头和尾向中间靠近，比较数值，将较大的放在结果数组的最后<br>注意：result若不用malloc申请内存的话，在函数结束后会被注销，无法通过返回值访问到结果</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">sortedSquares</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span>* returnSize)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *num = nums;</span><br><span class="line">    <span class="type">int</span> *num2=nums+numsSize<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> *result = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*numsSize);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i=numsSize<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n1,n2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(num&lt;=num2)</span><br><span class="line">    &#123;</span><br><span class="line">        n1 = (*num) * (*num);</span><br><span class="line">        n2 = (*num2) * (*num2);</span><br><span class="line">        <span class="keyword">if</span>(n1&lt;n2)</span><br><span class="line">        &#123;</span><br><span class="line">            result[i] = n2;</span><br><span class="line">            i--;</span><br><span class="line">            num2--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            result[i] = n1;</span><br><span class="line">            num++;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *returnSize = numsSize;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、<br>(<a href="https://leetcode-cn.com/problems/rotate-array/solution/xuan-zhuan-shu-zu-by-leetcode-solution-nipk/">中等-189. 轮转数组</a>)给你一个数组，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。</p>
<p>方法一、<br>思路：申请一块大小为k个int的空间用来装向右移动超出范围的部分，再将原数组进行移动，最后将超出部分的值赋值到原数组前部<br>注意：在开始的时候需要判断移动的长度是否超出数组长度，若超出需要对其取数组大小的模</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;numsSize)&#123;</span><br><span class="line">        k = k%numsSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> *T = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*k);</span><br><span class="line">    <span class="type">int</span> *num2 = nums+numsSize;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        T[i] = *(num2-k+i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=numsSize-k<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        nums[i+k] = nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        nums[i] = T[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法二、<br>思路：将数组中的元素一个一个进行交换，避免内存开销</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp1,tmp2;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;numsSize)&#123;</span><br><span class="line">        k = k%numsSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> start=<span class="number">0</span>;count&lt;numsSize;start++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> current = start;</span><br><span class="line">        tmp1 = nums[current];</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="type">int</span> n = (current+k)%numsSize;</span><br><span class="line">            tmp2 = nums[n];</span><br><span class="line">            nums[n] = tmp1;</span><br><span class="line">            tmp1 = tmp2;</span><br><span class="line">            current = n;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;<span class="keyword">while</span>(start!=current);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法三、<br>思路：将数组进行一次整体翻转，之后进行两次局部翻转</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">turn</span><span class="params">(<span class="type">int</span> *nums,<span class="type">int</span> numsSize)</span>;</span><br><span class="line">    k = k%numsSize;</span><br><span class="line">    turn(nums,numsSize);</span><br><span class="line">    turn(nums,k);</span><br><span class="line">    turn(nums+k,numsSize-k);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">turn</span><span class="params">(<span class="type">int</span> *nums,<span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;numsSize/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        tmp = nums[i];</span><br><span class="line">        nums[i] = nums[numsSize-i<span class="number">-1</span>];</span><br><span class="line">        nums[numsSize-i<span class="number">-1</span>] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6、<br>(<a href="https://leetcode-cn.com/problems/move-zeroes/">简单-283. 移动零</a>)给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。<br>请注意 ，必须在不复制数组的情况下原地对数组进行操作<br>思路：使用双指针，左指针指向当前已经处理好的序列的尾部，右指针指向待处理序列的头部。右指针不断向右移动，每次右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。左指针左边均为非零数，右指针左边直到左指针处均为零</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> n1,n2,tmp;</span><br><span class="line">    n1 = <span class="number">0</span>;</span><br><span class="line">    n2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(nums[n1]!=<span class="number">0</span>&amp;&amp;n1&lt;numsSize<span class="number">-1</span>)&#123;</span><br><span class="line">            n1++;</span><br><span class="line">        &#125;</span><br><span class="line">        n2 = n1;</span><br><span class="line">        <span class="keyword">while</span>(nums[n2]==<span class="number">0</span>&amp;&amp;n2&lt;numsSize<span class="number">-1</span>)&#123;</span><br><span class="line">            n2++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[n1]==<span class="number">0</span>&amp;&amp;nums[n2]!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">//                printf(&quot;%d   %d\n&quot;,n1,n2);</span></span><br><span class="line">            tmp = nums[n1];</span><br><span class="line">            nums[n1] = nums[n2];</span><br><span class="line">            nums[n2] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        n1++;</span><br><span class="line">        n2++;</span><br><span class="line">    &#125;<span class="keyword">while</span>(n2&lt;=numsSize<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>(<a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">简单-167. 两数之和 II - 输入有序数组</a>)给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列 ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 &lt;&#x3D; index1 &lt; index2 &lt;&#x3D; numbers.length .以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。你所设计的解决方案必须只使用常量级的额外空间。<br>思路：使用双指针，从左右两边向中间靠近，两数之和大于target就右指针向左移动，两数之和小于target就左指针向右移动<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">twoSum</span><span class="params">(<span class="type">int</span>* numbers, <span class="type">int</span> numbersSize, <span class="type">int</span> target, <span class="type">int</span>* returnSize)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>,right = numbersSize<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> *c = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">2</span>);</span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="type">int</span> sum = numbers[left]+numbers[right];</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            c[<span class="number">0</span>] = left+<span class="number">1</span>;</span><br><span class="line">            c[<span class="number">1</span>] = right+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>8、<br>(<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/">简单-557. 反转字符串中的单词 III</a>)给定一个字符串 s ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。（自己增加难度，没看到空格只有一个）<br>思路：两个指针确定单词的长度，使用turn函数对单词进行翻转</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> * <span class="title function_">reverseWords</span><span class="params">(<span class="type">char</span> * s)</span>&#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">strlen</span>(s);</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(s[l]==<span class="string">&#x27; &#x27;</span>&amp;&amp;l&lt;=size<span class="number">-1</span>)&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(s[r]!=<span class="string">&#x27; &#x27;</span>&amp;&amp;r&lt;=size<span class="number">-1</span>)&#123;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        turn(s,l,r<span class="number">-1</span>);</span><br><span class="line">        l = r;</span><br><span class="line">        <span class="keyword">while</span>(s[r]==<span class="string">&#x27; &#x27;</span>&amp;&amp;r&lt;=size<span class="number">-1</span>)&#123;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l==size<span class="number">-1</span>||r==size<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(r&lt;size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">turn</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        c = s[r];</span><br><span class="line">        s[r] = s[l];</span><br><span class="line">        s[l] = c;</span><br><span class="line">        l++;</span><br><span class="line">        r--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title>学习计划</title>
    <url>/2022/03/03/%E5%AD%A6%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h1 id="调剂学校"><a href="#调剂学校" class="headerlink" title="调剂学校"></a>调剂学校</h1><p>桂林电子科技大学<br>华南农业大学<br>汕头大学<br>山东科技大学<br>江南大学<br>东莞理工大学<br>山东交通大学</p>
<h1 id="待学习内容"><a href="#待学习内容" class="headerlink" title="待学习内容"></a>待学习内容</h1><p>数据结构<br>机器学习<br>C   —   ccf</p>
<p>SQL<br>spark<br>css+html+vue</p>
<h1 id="待学知识点"><a href="#待学知识点" class="headerlink" title="待学知识点"></a>待学知识点</h1><p>弗洛伊德<br>克鲁斯卡尔<br>地杰斯特拉</p>
]]></content>
      <categories>
        <category>杂乱</category>
      </categories>
      <tags>
        <tag>复试</tag>
        <tag>计划</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言学习杂乱知识点</title>
    <url>/2022/02/23/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E6%9D%82%E4%B9%B1%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>一、</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *i, *j;          <span class="comment">// 定义了两个指针变量 i 和 j（i,j分别是指向整数类型的指针）</span></span><br><span class="line"><span class="type">int</span> **p; 或 <span class="type">int</span>** p; <span class="comment">// 复合指针，p 是一个指向整型的指针的指针</span></span><br><span class="line"><span class="type">int</span>(*p)();           <span class="comment">// 定义了一个指向函数的指针变量 p，用来保存函数的入口地址，此函数返回整形值</span></span><br><span class="line">max(<span class="type">int</span> *i, <span class="type">int</span> *j)  <span class="comment">// 函数 max() 首部定义了 2 个形参: i 和 j 指针变量</span></span><br><span class="line"><span class="type">char</span> *<span class="built_in">string</span> = <span class="string">&quot;Hello world!&quot;</span>;  <span class="comment">// 定义了一个字符型指针变量 string，用来保存字符串常量的首地址</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *STRING;           <span class="comment">// 定义了一个字符指针类型 STRING</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span> *<span class="title">struct_pointer</span>;</span>     <span class="comment">// 定义了一个指向结构体的指针（tag 是结构体标签）</span></span><br></pre></td></tr></table></figure>

<p>二、<br>直接使用数组名和&amp;+数组名得到的结果是一样的，都是数组第一个元素的地址</p>
<p>三、<br>数组指针</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">arrayPointer</span><span class="params">(<span class="type">int</span> (*a)[<span class="number">3</span>])</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,(*a)[<span class="number">0</span>]);       <span class="comment">// 2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*(*(a+<span class="number">1</span>)+<span class="number">1</span>) );  <span class="comment">// 4</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*((*a+<span class="number">5</span>)));     <span class="comment">// 8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">9</span>&#125;,&#123;<span class="number">7</span>,<span class="number">4</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>&#125;&#125;;</span><br><span class="line">    arrayPointer(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>四、<br>scanf不能接受空格，sanf把空格当成结束符，一般遇到有空格的字符串得使用gets函数接受读取，gets函数可以接收有空格的字符串</p>
<p>五、<br>fopen(char <em>filename, char <em>mode) 读取文件的时候，第一个参数是文件路径，第二个参数是打开方式，**第二个参数必须是字符串</em></em><br>remove(char *filename) filename为要删除的文件名，可以为一目录。如果参数filename 为一文件，则调用unlink()处理；若参数filename 为一目录，则调用rmdir()来处理。</p>
<p>六、<br>printf的参数列表执行顺序是从右到左，注意顺序！</p>
<p>七、</p>
]]></content>
      <categories>
        <category>复试</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言的排序算法实现</title>
    <url>/2022/02/22/C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>每次交换两个，一轮循环后最大的值会在最后</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序-基础</span></span><br><span class="line"><span class="comment">// 升序排列</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">list</span>[] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">-1</span>, <span class="number">7</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> min, tmp;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(<span class="built_in">list</span>) / <span class="keyword">sizeof</span>(<span class="built_in">list</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>[j]&gt;<span class="built_in">list</span>[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                tmp = <span class="built_in">list</span>[j];</span><br><span class="line">                <span class="built_in">list</span>[j] = <span class="built_in">list</span>[j+<span class="number">1</span>];</span><br><span class="line">                <span class="built_in">list</span>[j+<span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">list</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>每次选出最小的放在最前，只进行一次交换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择排序-基础</span></span><br><span class="line"><span class="comment">// 升序排列</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">list</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">-1</span>, <span class="number">7</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> min, tmp;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(<span class="built_in">list</span>) / <span class="keyword">sizeof</span>(<span class="built_in">list</span>[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">list</span>[j] &lt; <span class="built_in">list</span>[min])</span><br><span class="line">            &#123;</span><br><span class="line">                min = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = <span class="built_in">list</span>[i];</span><br><span class="line">        <span class="built_in">list</span>[i] = <span class="built_in">list</span>[min];</span><br><span class="line">        <span class="built_in">list</span>[min] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">list</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>选第一个元素为基准，从右向左找一个比基准小的元素，从左往右找一个比基准大的元素，交换这两个元素直到左右相遇，这时将改点元素与基准元素进行交换，至此基准元素左边都比基准小，右边都比基准大。之后重复改过程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> *<span class="built_in">list</span>, <span class="type">int</span> left, <span class="type">int</span> right)</span>;</span><br><span class="line"><span class="comment">// 快速排序-数组</span></span><br><span class="line"><span class="comment">// 升序排列</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// &#123;   printf(&quot;...........................&quot;);</span></span><br><span class="line">    <span class="type">int</span> <span class="built_in">list</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">-1</span>, <span class="number">7</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> min, tmp;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(<span class="built_in">list</span>) / <span class="keyword">sizeof</span>(<span class="built_in">list</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接使用数组名就是数组第一个元素的地址</span></span><br><span class="line">    quickSort(<span class="built_in">list</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, <span class="built_in">list</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span> *<span class="built_in">list</span>, <span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 这种方法传入数组可以不用返回</span></span><br><span class="line">    <span class="type">int</span> mark = <span class="built_in">list</span>[left];</span><br><span class="line">    <span class="type">int</span> tmp;</span><br><span class="line">    <span class="type">int</span> r = right;</span><br><span class="line">    <span class="type">int</span> l = left+<span class="number">1</span>;   <span class="comment">// 注意这里不能包括标记点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注意这里需要先移动右边再移动左边</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">list</span>[r] &gt;= mark &amp;&amp; r &gt; l)</span><br><span class="line">        &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">list</span>[l] &lt; mark &amp;&amp; l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l != r)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = <span class="built_in">list</span>[l];</span><br><span class="line">            <span class="built_in">list</span>[l] = <span class="built_in">list</span>[r];</span><br><span class="line">            <span class="built_in">list</span>[r] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tmp = <span class="built_in">list</span>[left];</span><br><span class="line">    <span class="built_in">list</span>[left] = <span class="built_in">list</span>[r];</span><br><span class="line">    <span class="built_in">list</span>[r] = tmp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    quickSort(<span class="built_in">list</span>, left, (r - <span class="number">1</span>));</span><br><span class="line">    quickSort(<span class="built_in">list</span>, (r + <span class="number">1</span>), right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>复试</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言网站</title>
    <url>/2022/02/22/C%E8%AF%AD%E8%A8%80%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h1><p><a href="http://c.biancheng.net/view/368.html">C语言数组指针和指针数组</a> </p>
<p><a href="https://blog.csdn.net/xiaoboliu0602/article/details/78736524">C语言星号*的十种用法</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *i, *j;          <span class="comment">// 定义了两个指针变量 i 和 j（i,j分别是指向整数类型的指针）</span></span><br><span class="line"><span class="type">int</span> **p; 或 <span class="type">int</span>** p; <span class="comment">// 复合指针，p 是一个指向整型的指针的指针</span></span><br><span class="line"><span class="type">int</span>(*p)();           <span class="comment">// 定义了一个指向函数的指针变量 p，用来保存函数的入口地址，此函数返回整形值</span></span><br><span class="line">max(<span class="type">int</span> *i, <span class="type">int</span> *j)  <span class="comment">// 函数 max() 首部定义了 2 个形参: i 和 j 指针变量</span></span><br><span class="line"><span class="type">char</span> *<span class="built_in">string</span> = <span class="string">&quot;Hello world!&quot;</span>;  <span class="comment">// 定义了一个字符型指针变量 string，用来保存字符串常量的首地址</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> *STRING;           <span class="comment">// 定义了一个字符指针类型 STRING</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span> *<span class="title">struct_pointer</span>;</span>     <span class="comment">// 定义了一个指向结构体的指针（tag 是结构体标签）</span></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/u014027680/article/details/82707946">C语言打印错误信息</a></p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p><a href="http://c.biancheng.net/view/507.html">C语言版辗转相除法求最大公约数</a></p>
<p><a href="https://blog.csdn.net/pengzonglu7292/article/details/84938910">快速排序讲解及代码</a></p>
<p><a href="https://www.jb51.net/article/98966.htm">螺旋矩阵</a></p>
<p><a href="https://blog.csdn.net/qiaoermeng/article/details/88543467">弦截法求方程近似根</a></p>
<p><a href="https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-by-leetcode-solution-f0xw/">二分法</a></p>
]]></content>
      <categories>
        <category>复试</category>
      </categories>
      <tags>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title>spark-广播变量</title>
    <url>/2022/02/15/spark-%E5%B9%BF%E6%92%AD%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<p>广播变量用来高效分发较大的对象。向所有工作节点发送一个较大的<strong>只读值</strong>，以供一个或多个 Spark 操作使用。比如，如果你的应用需要向所有节点发送一个较大的只读查询表，广播变量用起来都很顺手。在多个并行操作中使用同一个变量，但是 Spark 会为每个任务分别发送</p>
<p>若不使用广播变量，则可能会因为闭包检测，导致一个executor中会有多个重复数据降低效率</p>
<p>广播变量是每个Executor中一个以共享，而不是整个应用有一个</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">List</span>( (<span class="string">&quot;a&quot;</span>,<span class="number">1</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">2</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">3</span>), (<span class="string">&quot;d&quot;</span>, <span class="number">4</span>) ),<span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>( (<span class="string">&quot;a&quot;</span>,<span class="number">4</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">5</span>), (<span class="string">&quot;c&quot;</span>, <span class="number">6</span>), (<span class="string">&quot;d&quot;</span>, <span class="number">7</span>) )</span><br><span class="line"><span class="comment">// 声明广播变量</span></span><br><span class="line"><span class="keyword">val</span> broadcast: <span class="type">Broadcast</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = sc.broadcast(list)</span><br><span class="line"><span class="keyword">val</span> resultRDD: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>))] = rdd1.map &#123;</span><br><span class="line"> <span class="keyword">case</span> (key, num) =&gt; &#123;</span><br><span class="line"> <span class="keyword">var</span> num2 = <span class="number">0</span></span><br><span class="line"> <span class="comment">// 使用广播变量</span></span><br><span class="line"> <span class="keyword">for</span> ((k, v) &lt;- broadcast.value) &#123;</span><br><span class="line"> <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line"> num2 = v</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> (key, (num, num2))</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>寒假学习</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>spark-累加器</title>
    <url>/2022/02/15/spark-%E7%B4%AF%E5%8A%A0%E5%99%A8/</url>
    <content><![CDATA[<p>累加器——分布式共享只写变量<br>累加器用来把 Executor 端变量信息聚合到 Driver 端。在 Driver 程序中定义的变量，在Executor 端的每个 Task 都会得到这个变量的一份新的副本，每个 task 更新这些副本的值后，传回 Driver 端进行 merge</p>
<p><strong>注意</strong>：如果将累加器放在转算算子中，可能会出现少加和多加的情况。</p>
<h1 id="系统累加器"><a href="#系统累加器" class="headerlink" title="系统累加器"></a>系统累加器</h1><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line"><span class="comment">// 声明累加器</span></span><br><span class="line"><span class="keyword">var</span> sum = sc.longAccumulator(<span class="string">&quot;sum&quot;</span>);</span><br><span class="line">rdd.foreach(</span><br><span class="line"> num =&gt; &#123;</span><br><span class="line"> <span class="comment">// 使用累加器</span></span><br><span class="line"> sum.add(num)   </span><br><span class="line"> &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 获取累加器的值</span></span><br><span class="line">println(<span class="string">&quot;sum = &quot;</span> + sum.value)</span><br></pre></td></tr></table></figure>

<h1 id="自定义累加器"><a href="#自定义累加器" class="headerlink" title="自定义累加器"></a>自定义累加器</h1><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">spark_ACC</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;sparkAcc&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> dataRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;spark&quot;</span>, <span class="string">&quot;scala&quot;</span>, <span class="string">&quot;hello&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建累加器对象并向spark进行注册</span></span><br><span class="line">    <span class="keyword">val</span> wcAcc = <span class="keyword">new</span> <span class="type">MyAccumulator</span>()</span><br><span class="line">    sc.register(wcAcc)</span><br><span class="line"></span><br><span class="line">    dataRDD.foreach(word =&gt; &#123;</span><br><span class="line">      wcAcc.add(word)</span><br><span class="line">    &#125;)</span><br><span class="line">    println(wcAcc.value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义累加器</span></span><br><span class="line"><span class="comment">// 1. 继承 AccumulatorV2，并设定泛型</span></span><br><span class="line"><span class="comment">//   In：累加器输入的数据类型</span></span><br><span class="line"><span class="comment">//   OUT：累加器输出的数据类型</span></span><br><span class="line"><span class="comment">// 2. 重写累加器的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCountAccumulator</span> <span class="keyword">extends</span> <span class="title">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]] </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> map: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = mutable.<span class="type">Map</span>()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 累加器是否为初始状态</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isZero</span></span>: <span class="type">Boolean</span> = &#123;</span><br><span class="line">    map.isEmpty</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 复制累加器</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>(): <span class="type">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]] = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">WordCountAccumulator</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置累加器</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    map.clear()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向累加器中增加数据 (In)</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(word: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 查询 map 中是否存在相同的单词</span></span><br><span class="line">    <span class="comment">// 如果有相同的单词，那么单词的数量加 1</span></span><br><span class="line">    <span class="comment">// 如果没有相同的单词，那么在 map 中增加这个单词</span></span><br><span class="line">    map(word) = map.getOrElse(word, <span class="number">0</span>L) + <span class="number">1</span>L</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 合并累加器</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(other: <span class="type">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> map1 = <span class="keyword">this</span>.map</span><br><span class="line">    <span class="keyword">val</span> map2 = other.value</span><br><span class="line">    map2.foreach &#123;</span><br><span class="line">      <span class="keyword">case</span> (word, count) =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> newCount: <span class="type">Long</span> = map1.getOrElse(word, <span class="number">0</span>L) + count</span><br><span class="line">        map1.update(word, newCount)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回累加器的结果 （Out）</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>寒假学习</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>spark-分区器</title>
    <url>/2022/02/15/spark-%E5%88%86%E5%8C%BA%E5%99%A8/</url>
    <content><![CDATA[<p>spark的分区器：只有涉及到 key-value 类型的RDD才会用到分区器，因为分区是以key分区的<br>Spark 默认的分区器是 HashPartitioner，此外还有RangePartitioner</p>
<p>自定义分区器需要继承Partitioner抽象类，重写两个方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">object spark01_partitioner &#123;</span><br><span class="line">  def main(args: Array[String]): Unit = &#123;</span><br><span class="line">    val sparkConf = new SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;testPartitioner&quot;)</span><br><span class="line">    val sc = new SparkContext(sparkConf);</span><br><span class="line"></span><br><span class="line">    val dataRDD: RDD[(String, Int)] = sc.makeRDD(List(</span><br><span class="line">      (&quot;a&quot;, 1),</span><br><span class="line">      (&quot;a&quot;, 3),</span><br><span class="line">      (&quot;b&quot;, 3),</span><br><span class="line">      (&quot;b&quot;, 2),</span><br><span class="line">      (&quot;c&quot;, 4)</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    val partRDD: RDD[(String, Int)] = dataRDD.partitionBy(new myPartitioner)</span><br><span class="line">    partRDD.saveAsTextFile(&quot;output&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 继承Partitioner抽象类，重写两个方法</span><br><span class="line">class myPartitioner extends Partitioner&#123;</span><br><span class="line">  // 分区数量</span><br><span class="line">  override def numPartitions: Int = 3</span><br><span class="line"></span><br><span class="line">  // 根据数据的key值返回数据所在分区的索引</span><br><span class="line">  override def getPartition(key: Any): Int = &#123;</span><br><span class="line">    key match &#123;</span><br><span class="line">      case &quot;a&quot;=&gt;0</span><br><span class="line">      case &quot;b&quot;=&gt;1</span><br><span class="line">      case _=&gt;2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    if (key == &quot;a&quot;)&#123;0&#125;</span><br><span class="line">//    if (key == &quot;b&quot;)&#123;1&#125;</span><br><span class="line">//    else &#123;2&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>寒假学习</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>spark-持久化</title>
    <url>/2022/02/15/spark-%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<p><em>注意与<strong>序列化</strong>进行区分</em>  </p>
<p>RDD 通过 cache(存入内存) 或者 persist 方法将前面的计算结果缓存，默认情况下会把数据以缓存在 JVM 的堆内存中。但是并不是这两个方法被调用时立即缓存，而是触发后面的 action 算子时，该 RDD 将会被缓存在计算节点的内存中，并供后面重用</p>
<p>cache只能将数据保存到内存中，若想将数据保存到磁盘中，需要更改存储级别，在persist中传入，分别是StorageLevel中的MEMORY_ONLY、DISK_ONLY、DISK_ONLY_2(另外存一个备份)、MEMORY_AND_DISK…等，使用方法如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">rdd.persist(<span class="type">StorageLevel</span>.<span class="type">MEMORY_ONLY</span>)</span><br></pre></td></tr></table></figure>

<p>持久化不一定是为了数据的重用，也可能是数据计算的耗时很大，为了避免之后出现错误要从头计算，进行持久化可以提高性能和提高安全性</p>
<p>检查点(CheckPoint)：</p>
<ul>
<li>使用方法和cache类似</li>
<li>需要落盘，需要设置文件路径</li>
<li>检查点路劲保存的文件，在程序执行完之后不会删除(区别于cache和persist)</li>
<li>一般的存储路径都是分布式文件系统，如HDFS</li>
</ul>
<p><strong>cache、persist和checkpoint的对比</strong>：<br>cache：</p>
<ul>
<li>将数据临时存储在内存中进行数据重用</li>
<li>会在血缘关系中添加新的依赖，一旦出现问题，重新读取数据</li>
</ul>
<p>persist：</p>
<ul>
<li>将数据临时存储在内存中或磁盘文件中进行数据重用</li>
<li>涉及到磁盘IO，性能较低，但是数据安全</li>
<li>如果作业执行完毕，临时存储的数据文件就对被删除</li>
<li>会在血缘关系中添加新的依赖，一旦出现问题，重新读取数据</li>
</ul>
<p>checkpoint：</p>
<ul>
<li>将数据临时存储在内存中或磁盘文件中进行数据重用</li>
<li>涉及到磁盘IO，性能较低，但是数据安全</li>
<li>为了保证数据安全，一般情况下会独立执行作业（产生多余消耗）</li>
<li>为了提高效率，避免第三条，可以和cache联合使用</li>
<li>会切断血缘关系，重新建立新的血缘关系，出现问题从检查点读取数据</li>
</ul>
]]></content>
      <categories>
        <category>寒假学习</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>spark-阶段划分</title>
    <url>/2022/02/14/spark-%E9%98%B6%E6%AE%B5%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<p>程序中每出现一次shuffle操作，阶段数（Stage）就会自动新建一个<br>总阶段数 &#x3D; shuffle次数+1(resultStage)</p>
<p>RDD 任务切分中间分为：Application、Job、Stage 和 Task:</p>
<ul>
<li>Application：初始化一个 SparkContext 即生成一个 Application；</li>
<li>Job：一个 Action 算子就会生成一个 Job；</li>
<li>Stage：Stage 等于宽依赖(ShuffleDependency)的个数加 1；</li>
<li>Task：一个 Stage 阶段中，最后一个 RDD 的分区个数就是 Task 的个数。</li>
</ul>
]]></content>
      <categories>
        <category>寒假学习</category>
      </categories>
      <tags>
        <tag>spark</tag>
        <tag>RDD</tag>
      </tags>
  </entry>
  <entry>
    <title>spark-RDD依赖关系</title>
    <url>/2022/02/13/spark-RDD%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<p>依赖关系，其实就是两个相邻 RDD 之间的关系<br>所谓血缘关系，就是一组连续的依赖关系<br>RDD 只支持粗粒度转换，即在大量记录上执行的单个操作。将创建 RDD 的一系列 Lineage（血统）记录下来，以便恢复丢失的分区。RDD 的 Lineage 会记录 RDD 的元数据信息和转换行为，当该 RDD 的部分分区数据丢失时，它可以根据这些信息来重新运算和恢复丢失的数据分区。<br><em>使用toDebugString属性可以查看RDD的血缘关系，dependencies可以查看RDD的依赖关系</em></p>
<p>窄依赖（OneToOne依赖）：新的RDD的一个分区依赖于旧的RDD的一个分区数据<br>宽依赖（Shuffle依赖）：新的RDD的一个分区依赖于旧的RDD的多个分区数据，RDD从旧到新的过程中有shuffle操作</p>
]]></content>
      <categories>
        <category>寒假学习</category>
      </categories>
      <tags>
        <tag>spark</tag>
        <tag>RDD</tag>
      </tags>
  </entry>
  <entry>
    <title>spark-序列化</title>
    <url>/2022/02/12/spark-%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<p>序列化后的类可以在网络中进行传播</p>
<p>Search类实现按照条件进行筛选的功能<br>主要注意以下两点：</p>
<ul>
<li>1.scala中构造参数是类的属性</li>
<li>2.可以不引入特质，将值与类剥离实现功能</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">spark_serial</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;Serial&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">Array</span>(<span class="string">&quot;hello world&quot;</span>, <span class="string">&quot;hello spark&quot;</span>,</span><br><span class="line">      <span class="string">&quot;hive&quot;</span>, <span class="string">&quot;atguigu&quot;</span>))</span><br><span class="line">    <span class="comment">//3.1 创建一个 Search 对象</span></span><br><span class="line">    <span class="keyword">val</span> search = <span class="keyword">new</span> <span class="type">Search</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="comment">//3.2 函数传递</span></span><br><span class="line">    search.getMatch1(rdd).collect().foreach(println)</span><br><span class="line">    <span class="comment">//3.3 属性传递</span></span><br><span class="line">    search.getMatch2(rdd).collect().foreach(println)</span><br><span class="line">    <span class="comment">//4.关闭连接</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// scala中构造参数是类的属性</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Search</span>(<span class="params">query:<span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span></span>(s: <span class="type">String</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    s.contains(query)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 函数序列化案例</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getMatch1</span> </span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]): <span class="type">RDD</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">    <span class="comment">//rdd.filter(this.isMatch)</span></span><br><span class="line">    rdd.filter(isMatch)    <span class="comment">// 等同于上面一句</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 属性序列化案例</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getMatch2</span></span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]): <span class="type">RDD</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">    rdd.filter(x =&gt; x.contains(query))</span><br><span class="line">    <span class="comment">// 也可以不引入特质，用下面这种方法，将值与类剥离实现功能</span></span><br><span class="line">    <span class="comment">//val q = query</span></span><br><span class="line">    <span class="comment">//rdd.filter(x =&gt; x.contains(q))</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Java 的序列化能够序列化任何的类。但是比较重（字节多），序列化后，对象的提交也比较大。Spark 出于性能的考虑，Spark2.0 开始支持另外一种 Kryo 序列化机制。Kryo 速度是 Serializable 的 10 倍。当 RDD 在 Shuffle 数据的时候，简单数据类型、数组和字符串类型已经在 Spark 内部使用 Kryo 来序列化。<br>注意：即使使用 Kryo 序列化，也要继承 Serializable 接口。<br>Kryo序列化绕过了java序列化规则，不受transient关键字（含有改关键字的属性不会被序列化）影响</p>
]]></content>
      <categories>
        <category>寒假学习</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>spark-闭包检测</title>
    <url>/2022/02/12/spark-%E9%97%AD%E5%8C%85%E6%A3%80%E6%B5%8B/</url>
    <content><![CDATA[<p>闭包是一个函数，返回值依赖于声明在函数外部的一个或多个变量。<br>闭包通常来讲可以简单的认为是可以访问一个函数里面局部变量的另外一个函数。</p>
<p>从计算的角度, 算子以外的代码都是在 Driver 端执行, 算子里面的代码都是在 Executor端执行。那么在 scala 的函数式编程中，就会导致算子内经常会用到算子外的数据，这样就形成了闭包的效果，如果使用的算子外的数据无法序列化，就意味着无法传值给 Executor端执行，就会发生错误，所以需要在执行任务计算前，检测闭包内的对象是否可以进行序列化，这个操作我们称之为闭包检测</p>
<p>RDD算子中传递的函数是闭包函数，那么就会进行闭包检测，无论外部函数是否有进行调用。</p>
]]></content>
      <categories>
        <category>寒假学习</category>
      </categories>
      <tags>
        <tag>spark</tag>
      </tags>
  </entry>
  <entry>
    <title>spark-wordcount的不同方式实现</title>
    <url>/2022/02/12/spark-wordcount%E7%9A%84%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>本篇主要记录用几个不同的算子实现WordCount功能</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordcount</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> =&#123;</span><br><span class="line">  <span class="comment">// groupBy</span></span><br><span class="line">  <span class="keyword">val</span> dataRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;hello scala&quot;</span>, <span class="string">&quot;hello spark&quot;</span>))</span><br><span class="line">  <span class="keyword">val</span> flatRDD: <span class="type">RDD</span>[<span class="type">String</span>] = dataRDD.flatMap(_.split(&#x27; &#x27;))</span><br><span class="line">  <span class="keyword">val</span> groupRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">String</span>])] = flatRDD.groupBy(word =&gt; word)</span><br><span class="line">  <span class="keyword">val</span> mapRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = groupRDD.mapValues(_.toList.size)</span><br><span class="line">  mapRDD.collect().foreach(println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordcount</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> =&#123;</span><br><span class="line">  <span class="comment">// groupByKey</span></span><br><span class="line">  <span class="keyword">val</span> dataRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;hello scala&quot;</span>, <span class="string">&quot;hello spark&quot;</span>))</span><br><span class="line">  <span class="keyword">val</span> flatRDD: <span class="type">RDD</span>[<span class="type">String</span>] = dataRDD.flatMap(_.split(&#x27; &#x27;))</span><br><span class="line">  <span class="keyword">val</span> mapRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = flatRDD.map &#123;</span><br><span class="line">    word =&gt; (word, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> newMapRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = mapRDD.groupByKey().mapValues(_.toList.size)</span><br><span class="line">  newMapRDD.collect().foreach(println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordcount</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> =&#123;</span><br><span class="line">  <span class="comment">// reduceByKey</span></span><br><span class="line">  <span class="keyword">val</span> dataRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;hello scala&quot;</span>, <span class="string">&quot;hello spark&quot;</span>))</span><br><span class="line">  <span class="keyword">val</span> flatRDD: <span class="type">RDD</span>[<span class="type">String</span>] = dataRDD.flatMap(_.split(&#x27; &#x27;))</span><br><span class="line">  <span class="keyword">val</span> mapRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = flatRDD.map &#123;</span><br><span class="line">    word =&gt; (word, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> newMapRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = mapRDD.reduceByKey(_+_)</span><br><span class="line">  newMapRDD.collect().foreach(println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordcount</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> =&#123;</span><br><span class="line">  <span class="comment">// aggregateByKey(foldByKey同理)</span></span><br><span class="line">  <span class="keyword">val</span> dataRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;hello scala&quot;</span>, <span class="string">&quot;hello spark&quot;</span>))</span><br><span class="line">  <span class="keyword">val</span> flatRDD: <span class="type">RDD</span>[<span class="type">String</span>] = dataRDD.flatMap(_.split(&#x27; &#x27;))</span><br><span class="line">  <span class="keyword">val</span> mapRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = flatRDD.map &#123;</span><br><span class="line">    word =&gt; (word, <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> newMapRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = mapRDD.aggregateByKey(<span class="number">0</span>)(_+_,_+_)</span><br><span class="line">  newMapRDD.collect().foreach(println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordcount</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> =&#123;</span><br><span class="line">  <span class="comment">// countByValue</span></span><br><span class="line">  <span class="keyword">val</span> dataRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;hello scala&quot;</span>, <span class="string">&quot;hello spark&quot;</span>))</span><br><span class="line">  <span class="keyword">val</span> flatRDD: <span class="type">RDD</span>[<span class="type">String</span>] = dataRDD.flatMap(_.split(&#x27; &#x27;))</span><br><span class="line">  <span class="keyword">val</span> countRDD: collection.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = flatRDD.countByValue()</span><br><span class="line">  countRDD.foreach(println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordcount</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> =&#123;</span><br><span class="line">  <span class="comment">// countByKey</span></span><br><span class="line">  <span class="keyword">val</span> dataRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;hello scala&quot;</span>, <span class="string">&quot;hello spark&quot;</span>))</span><br><span class="line">  <span class="keyword">val</span> flatRDD: <span class="type">RDD</span>[<span class="type">String</span>] = dataRDD.flatMap(_.split(&#x27; &#x27;))</span><br><span class="line">  <span class="keyword">val</span> mapRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = flatRDD.map(value =&gt; (value, <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">val</span> countRDD: collection.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = mapRDD.countByKey()</span><br><span class="line">  countRDD.foreach(println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wordcount</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> =&#123;</span><br><span class="line">  <span class="comment">// countByKey(aggregate、flod算子同理)</span></span><br><span class="line">  <span class="keyword">val</span> dataRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;hello scala&quot;</span>, <span class="string">&quot;hello spark&quot;</span>))</span><br><span class="line">  <span class="keyword">val</span> flatRDD: <span class="type">RDD</span>[<span class="type">String</span>] = dataRDD.flatMap(_.split(&#x27; &#x27;))</span><br><span class="line">  <span class="comment">// 这里是因为reduce的输入输出数据类型必须相同，将其转换为Map再进行运算</span></span><br><span class="line">  <span class="keyword">val</span> mapRDD: <span class="type">RDD</span>[mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]] = flatRDD.map(</span><br><span class="line">    word =&gt; &#123;</span><br><span class="line">      mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]((word, <span class="number">1</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">val</span> resultRDD: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = mapRDD.reduce(</span><br><span class="line">    (map1, map2) =&gt; &#123;</span><br><span class="line">      map2.foreach &#123;</span><br><span class="line">        <span class="keyword">case</span> (word, count) =&gt; &#123;</span><br><span class="line">          <span class="keyword">val</span> newCount = map1.getOrElse(word, <span class="number">0</span>L) + count</span><br><span class="line">          map1.update(word, newCount)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      map1</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  resultRDD.foreach(println)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>寒假学习</category>
      </categories>
      <tags>
        <tag>spark</tag>
        <tag>实操</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>spark案例实操1-广告点击数量排行</title>
    <url>/2022/02/12/spark%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%93%8D1-%E5%B9%BF%E5%91%8A%E7%82%B9%E5%87%BB%E6%95%B0%E9%87%8F%E6%8E%92%E8%A1%8C/</url>
    <content><![CDATA[<p>agent.log：时间戳，省份，城市，用户，广告，中间字段使用空格分隔<br>统计出每一个省份每个广告被点击数量排行的 Top3</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">spark04_practical_operation</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local&quot;</span>).setAppName(<span class="string">&quot;practicalOperation&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取源数据</span></span><br><span class="line">    <span class="keyword">val</span> dataRDD1: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">&quot;./data/agent.log&quot;</span>)</span><br><span class="line">    <span class="comment">// 删除多余列</span></span><br><span class="line">    <span class="keyword">val</span> dataRDD2= dataRDD1.map(value =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> l: <span class="type">Array</span>[<span class="type">String</span>] = value.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">      ((l(<span class="number">1</span>), l(<span class="number">4</span>)), <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 按照键进行聚合</span></span><br><span class="line">    <span class="keyword">val</span> reduceRDD: <span class="type">RDD</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)] = dataRDD2.reduceByKey(_ + _) </span><br><span class="line">    <span class="comment">// 改变数据的结构</span></span><br><span class="line">    <span class="keyword">val</span> dataRDD3: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">String</span>, <span class="type">Int</span>))] = reduceRDD.map &#123;</span><br><span class="line">      <span class="keyword">case</span> ((prv, ad), sum) =&gt; (prv, (ad, sum))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照省份进行分组</span></span><br><span class="line">    <span class="keyword">val</span> groupRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[(<span class="type">String</span>, <span class="type">Int</span>)])] = dataRDD3.groupByKey()</span><br><span class="line">    <span class="comment">// 对值进行map操作，排序出前选三</span></span><br><span class="line">    <span class="keyword">val</span> resultRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)])] = groupRDD.mapValues(</span><br><span class="line">      iter =&gt; &#123;</span><br><span class="line">        iter.toList.sortBy(_._2)(<span class="type">Ordering</span>.<span class="type">Int</span>.reverse).take(<span class="number">3</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    resultRDD.collect().foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(4,List((12,25), (2,22), (16,22)))</span><br><span class="line">(8,List((2,27), (20,23), (11,22)))</span><br><span class="line">(7,List((16,26), (26,25), (1,23)))</span><br><span class="line">(5,List((14,26), (12,21), (21,21)))</span><br><span class="line">(6,List((16,23), (24,21), (22,20)))</span><br><span class="line">(0,List((2,29), (24,25), (26,24)))</span><br><span class="line">(2,List((6,24), (21,23), (29,20)))</span><br><span class="line">(9,List((1,31), (28,21), (0,20)))</span><br><span class="line">(3,List((14,28), (28,27), (1,25)))</span><br><span class="line">(1,List((3,25), (6,23), (5,22)))</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>寒假学习</category>
      </categories>
      <tags>
        <tag>spark</tag>
        <tag>实操</tag>
        <tag>案例</tag>
        <tag>code</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据学习杂乱知识点</title>
    <url>/2022/02/09/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AD%A6%E4%B9%A0%E6%9D%82%E4%B9%B1%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>⎛⎝≥⏝⏝≤⎛⎝<br>1、HDFS集群的datnaode掉线超时时长的计算公式为： timeout &#x3D; 10 * dfs.heartbeat.interval + 2 * heartbeat.recheck.interval，不过heartbeat.recheck.interval的单位是ms，dfs.heartbeat.interval的单位是s<br>如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.heartbeat.interval<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>heartbeat.recheck.interval<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>2000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>需要34s才能感知到   </p>
<p>2、secondary:并非namenode的热备,当namenode挂掉的时候,它并不马上替换掉namenode提供服务<br>辅助namenode.分担其工作量,比如定期合并fsimage 和 edits ,并推送给namenode<br>在紧急的情况下 可辅助恢复namenode</p>
<p>3、HDFS不适合大量小文件的存储，因namenode将文件系统的元数据存放在内存中，因此存储的文件数目受限于 namenode的内存大小。HDFS中每个文件、目录、数据块占用150Bytes。如果存放的文件数目过多的话会占用很大的内存。</p>
<p>4、NameNode存储了元数据，并且调度，协调整个集群<br>DataNode主要用来存储数据</p>
<p>5、hive与mysql（传统数据库）的区别？<br>查询语言不同：hive是hql语言，mysql是sql语言<br>数据存储位置不同：hive是把数据存储在hdfs上，mysql数据是存储在自己的系统中<br>数据格式：hive数据格式用户可以自定义，mysql有自己的系统定义格式<br>数据更新：hive不支持数据更新，只可以读，不可以写，而sql支持数据更新<br>索引：hive没有索引，因此查询数据的时候是通过mapreduce很暴力的把数据都查询一遍，也造成了hive查询数据速度很慢的原因，而mysql有索引；<br>延迟性：hive延迟性高，原因就是上边一点所说的，而mysql延迟性低；<br>数据规模：hive存储的数据量超级大，而mysql只是存储一些少量的业务数据；<br>底层执行原理：hive底层是用的mapreduce，而mysql是excutor执行器。</p>
<p>6、</p>
]]></content>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>前端学习笔记</title>
    <url>/2022/02/09/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="html5"><a href="#html5" class="headerlink" title="html5"></a>html5</h1><h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h2><p>h1~h6一共有六级<br>关注语义而不要去关注样式</p>
]]></content>
      <categories>
        <category>寒假学习</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>RDD并行度和分区</title>
    <url>/2022/02/08/RDD%E5%B9%B6%E8%A1%8C%E5%BA%A6%E5%92%8C%E5%88%86%E5%8C%BA/</url>
    <content><![CDATA[<p>spark的分区器：只有涉及到 key-value 类型的RDD才会用到分区器，因为分区是以key分区的<br>Spark 默认的分区器是 HashPartitioner<br>待完成</p>
]]></content>
  </entry>
  <entry>
    <title>RDD算子</title>
    <url>/2022/02/08/RDD%E7%AE%97%E5%AD%90/</url>
    <content><![CDATA[<blockquote>
<p>摘抄于尚硅谷资料内容，用于个人学习</p>
</blockquote>
<p><em>RDD的创建感觉没必要另写一篇，就将就写在这前面</em></p>
<h2 id="RDD的创建"><a href="#RDD的创建" class="headerlink" title="RDD的创建"></a>RDD的创建</h2><h3 id="从集合（内存）中创建RDD"><a href="#从集合（内存）中创建RDD" class="headerlink" title="从集合（内存）中创建RDD"></a>从集合（内存）中创建RDD</h3><p>主要有两个方法，parallelize和makeRDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">&quot;local[*]&quot;</span>).setAppName(<span class="string">&quot;spark&quot;</span>)</span><br><span class="line"><span class="keyword">val</span> sparkContext = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"><span class="keyword">val</span> rdd1 = sparkContext.parallelize(</span><br><span class="line"> <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">val</span> rdd2 = sparkContext.makeRDD(</span><br><span class="line"> <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在底层makeRDD其实就是parallelize</p>
<h3 id="从外部存储（文件）创建RDD"><a href="#从外部存储（文件）创建RDD" class="headerlink" title="从外部存储（文件）创建RDD"></a>从外部存储（文件）创建RDD</h3><p>由外部存储系统的数据集创建 RDD 包括：本地的文件系统，所有 Hadoop 支持的数据集，比如 HDFS、HBase 等</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sparkContext.textFile(<span class="string">&quot;input&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="从其他-RDD-创建"><a href="#从其他-RDD-创建" class="headerlink" title="从其他 RDD 创建"></a>从其他 RDD 创建</h3><p>主要是通过一个 RDD 运算完后，再产生新的 RDD</p>
<h3 id="直接创建-RDD（new）"><a href="#直接创建-RDD（new）" class="headerlink" title="直接创建 RDD（new）"></a>直接创建 RDD（new）</h3><p>使用 new 的方式直接构造 RDD，一般由 Spark 框架自身使用</p>
<hr>
<p>RDD算子分为转换算子和行动算子两类，转换算子只是RDD的不断封装，不会进行实际的运算(类似于惰性计算)，直到程序遇到行动算子程序才开始按照继承关系进行运算。</p>
<h1 id="RDD转换算子"><a href="#RDD转换算子" class="headerlink" title="RDD转换算子"></a>RDD转换算子</h1><p>RDD根据数据处理方式的不同将算子整体上分为 Value 类型、双 Value 类型和 Key-Value类型</p>
<h2 id="Value类型"><a href="#Value类型" class="headerlink" title="Value类型"></a>Value类型</h2><h3 id="map算子"><a href="#map算子" class="headerlink" title="map算子"></a>map算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](f: <span class="type">T</span> =&gt; <span class="type">U</span>): <span class="type">RDD</span>[<span class="type">U</span>]</span><br></pre></td></tr></table></figure>
<p>将处理的数据逐条进行映射转换，这里的转换可以是类型的转换，也可以是值的转换<br>转换后数据量不会改变</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD: <span class="type">RDD</span>[<span class="type">Int</span>] = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">val</span> dataRDD1: <span class="type">RDD</span>[<span class="type">Int</span>] = dataRDD.map(</span><br><span class="line"> num =&gt; &#123;</span><br><span class="line">    num * <span class="number">2</span></span><br><span class="line"> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="mapPartition算子"><a href="#mapPartition算子" class="headerlink" title="mapPartition算子"></a>mapPartition算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapPartitions</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](</span><br><span class="line"> f: <span class="type">Iterator</span>[<span class="type">T</span>] =&gt; <span class="type">Iterator</span>[<span class="type">U</span>],</span><br><span class="line"> preservesPartitioning: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">RDD</span>[<span class="type">U</span>]</span><br></pre></td></tr></table></figure>
<p>将待处理的数据以分区为单位发送到计算节点进行处理，这里的处理是指可以进行任意的处理，哪怕是过滤数据<br>与map算子的比较：<strong>速度比map快、会长时间占用内存、数据量可能会有变化（减少或增多）</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1: <span class="type">RDD</span>[<span class="type">Int</span>] = dataRDD.mapPartitions(</span><br><span class="line"> datas =&gt; &#123;</span><br><span class="line">    datas.filter(_==<span class="number">2</span>)</span><br><span class="line"> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="mapPartitionsWithIndex算子"><a href="#mapPartitionsWithIndex算子" class="headerlink" title="mapPartitionsWithIndex算子"></a>mapPartitionsWithIndex算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapPartitionsWithIndex</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](</span><br><span class="line"> f: (<span class="type">Int</span>, <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; <span class="type">Iterator</span>[<span class="type">U</span>],</span><br><span class="line"> preservesPartitioning: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">RDD</span>[<span class="type">U</span>]</span><br></pre></td></tr></table></figure>
<p>同mapPartition算子，在处理时同时可以获取当前分区索引</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.mapPartitionsWithIndex(</span><br><span class="line"> (index, datas) =&gt; &#123;</span><br><span class="line">    datas.map(index, _)</span><br><span class="line"> &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="flatMap算子"><a href="#flatMap算子" class="headerlink" title="flatMap算子"></a>flatMap算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](f: <span class="type">T</span> =&gt; <span class="type">TraversableOnce</span>[<span class="type">U</span>]): <span class="type">RDD</span>[<span class="type">U</span>]</span><br></pre></td></tr></table></figure>
<p>将处理的数据进行扁平化后再进行映射处理，所以算子也称之为扁平映射</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(</span><br><span class="line"> <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>),<span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">),<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.flatMap(</span><br><span class="line"> list =&gt; list</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="glom算子"><a href="#glom算子" class="headerlink" title="glom算子"></a>glom算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">glom</span></span>(): <span class="type">RDD</span>[<span class="type">Array</span>[<span class="type">T</span>]]</span><br></pre></td></tr></table></figure>
<p>将同一个分区的数据直接转换为相同类型的内存数组进行处理，分区不变</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(</span><br><span class="line"> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">),<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD1:<span class="type">RDD</span>[<span class="type">Array</span>[<span class="type">Int</span>]] = dataRDD.glom() <span class="comment">//注意此处dataRDD1的数据类型</span></span><br></pre></td></tr></table></figure>

<h3 id="groupBy算子"><a href="#groupBy算子" class="headerlink" title="groupBy算子"></a>groupBy算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupBy</span></span>[<span class="type">K</span>](f: <span class="type">T</span> =&gt; <span class="type">K</span>)(<span class="keyword">implicit</span> kt: <span class="type">ClassTag</span>[<span class="type">K</span>]): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">Iterable</span>[<span class="type">T</span>])]</span><br></pre></td></tr></table></figure>
<p>将数据根据指定的规则进行分组, 分区数默认不变，但是数据会被打乱重新组合。极限情况下，数据可能被分在同一个分区中<br><strong>一个组的数据在一个分区中，但是并不是说一个分区中只有一个组</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按照奇偶对数据进行分组</span></span><br><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.groupBy(</span><br><span class="line">    _%<span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="filter算子"><a href="#filter算子" class="headerlink" title="filter算子"></a>filter算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(f: <span class="type">T</span> =&gt; <span class="type">Boolean</span>): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
<p>将数据根据指定的规则进行筛选过滤，符合规则的数据保留，不符合规则的数据丢弃。<br>当数据进行筛选过滤后，分区不变，但是分区内的数据可能不均衡，生产环境下，可能会出现数据倾斜。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(</span><br><span class="line"> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">),<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.filter(_%<span class="number">2</span> == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h3 id="sample算子"><a href="#sample算子" class="headerlink" title="sample算子"></a>sample算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span></span>(</span><br><span class="line">withReplacement: <span class="type">Boolean</span>,</span><br><span class="line"> fraction: <span class="type">Double</span>,</span><br><span class="line"> seed: <span class="type">Long</span> = <span class="type">Utils</span>.random.nextLong): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
<p>根据指定的规则从数据集中抽取数据</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(</span><br><span class="line"> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">),<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 抽取数据不放回（伯努利算法）</span></span><br><span class="line"><span class="comment">// 伯努利算法：又叫 0、1 分布。例如扔硬币，要么正面，要么反面。</span></span><br><span class="line"><span class="comment">// 具体实现：根据种子和随机算法算出一个数和第二个参数设置几率比较，小于第二个参数要，大于不</span></span><br><span class="line">要</span><br><span class="line"><span class="comment">// 第一个参数：抽取的数据是否放回，false：不放回</span></span><br><span class="line"><span class="comment">// 第二个参数：抽取的几率，范围在[0,1]之间,0：全不取；1：全取；</span></span><br><span class="line"><span class="comment">// 第三个参数：随机数种子</span></span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.sample(<span class="literal">false</span>, <span class="number">0.5</span>)</span><br><span class="line"><span class="comment">// 抽取数据放回（泊松算法）</span></span><br><span class="line"><span class="comment">// 第一个参数：抽取的数据是否放回，true：放回；false：不放回</span></span><br><span class="line"><span class="comment">// 第二个参数：重复数据的几率，范围大于等于 0.表示每一个元素被期望抽取到的次数</span></span><br><span class="line"><span class="comment">// 第三个参数：随机数种子</span></span><br><span class="line"><span class="keyword">val</span> dataRDD2 = dataRDD.sample(<span class="literal">true</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="distinct算子"><a href="#distinct算子" class="headerlink" title="distinct算子"></a>distinct算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distinct</span></span>()(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="literal">null</span>): <span class="type">RDD</span>[<span class="type">T</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distinct</span></span>(numPartitions: <span class="type">Int</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="literal">null</span>): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
<p>将数据集中重复的数据去重<br>若带参数则函数参数意义为分区数量，<del>函数柯里化参数是排序？</del><br><strong>去重原理</strong>：使用map算子把元素转为一个带有null的元组；使用reducebykey对具有相同key的元素进行统计；之后再使用map算子，取得元组中的单词元素，实现去重的效果。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(</span><br><span class="line"> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">),<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.distinct()</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = dataRDD.distinct(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="coalesce算子"><a href="#coalesce算子" class="headerlink" title="coalesce算子"></a>coalesce算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coalesce</span></span>(numPartitions: <span class="type">Int</span>, shuffle: <span class="type">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line"> partitionCoalescer: <span class="type">Option</span>[<span class="type">PartitionCoalescer</span>] = <span class="type">Option</span>.empty)</span><br><span class="line"> (<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="literal">null</span>):<span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
<p>根据数据量缩减分区，用于大数据集过滤后，提高小数据集的执行效率<br>当 spark 程序中，存在过多的小任务的时候，可以通过 coalesce 方法，收缩合并分区，减少分区的个数，减小任务调度成本<br>默认情况下是不会将一个分区内的数据打乱与其他分区组合的，可以选择第二个参数实现shuffle<br>该算子也可以扩大分区，但必须将shuffle置为true，否则没有意义</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(</span><br><span class="line"> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">),<span class="number">6</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.coalesce(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="repartition算子"><a href="#repartition算子" class="headerlink" title="repartition算子"></a>repartition算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repartition</span></span>(numPartitions: <span class="type">Int</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="literal">null</span>): <span class="type">RDD</span>[<span class="type">T</span>]   </span><br></pre></td></tr></table></figure>
<p>该操作内部其实执行的是 coalesce 操作，参数 shuffle 的默认值为 true。无论是将分区数多的<br>RDD 转换为分区数少的 RDD，还是将分区数少的 RDD 转换为分区数多的 RDD，repartition<br>操作都可以完成，因为无论如何都会经 shuffle 过程。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(</span><br><span class="line"> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">),<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.repartition(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h3 id="sortBy算子"><a href="#sortBy算子" class="headerlink" title="sortBy算子"></a>sortBy算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortBy</span></span>[<span class="type">K</span>](</span><br><span class="line"> f: (<span class="type">T</span>) =&gt; <span class="type">K</span>,</span><br><span class="line"> ascending: <span class="type">Boolean</span> = <span class="literal">true</span>,</span><br><span class="line"> numPartitions: <span class="type">Int</span> = <span class="keyword">this</span>.partitions.length)</span><br><span class="line"> (<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">K</span>], ctag: <span class="type">ClassTag</span>[<span class="type">K</span>]): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
<p>该操作用于排序数据。在排序之前，可以将数据通过 f 函数进行处理，之后按照 f 函数处理<br>的结果进行排序，默认为升序排列。排序后新产生的 RDD 的分区数与原 RDD 的分区数一<br>致。中间存在 shuffle 的过程</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(</span><br><span class="line"> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">),<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.sortBy(num=&gt;num, <span class="literal">false</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<h2 id="双Value类型"><a href="#双Value类型" class="headerlink" title="双Value类型"></a>双Value类型</h2><h3 id="intersection算子"><a href="#intersection算子" class="headerlink" title="intersection算子"></a>intersection算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection</span></span>(other: <span class="type">RDD</span>[<span class="type">T</span>]): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
<p>对源 RDD 和参数 RDD 求交集后返回一个新的 RDD </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"><span class="keyword">val</span> dataRDD = dataRDD1.intersection(dataRDD2)</span><br></pre></td></tr></table></figure>

<h3 id="union算子"><a href="#union算子" class="headerlink" title="union算子"></a>union算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span></span>(other: <span class="type">RDD</span>[<span class="type">T</span>]): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
<p>对源 RDD 和参数 RDD 求并集后返回一个新的 RDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = dataRDD1.union(dataRDD2)</span><br></pre></td></tr></table></figure>

<h3 id="subtract算子"><a href="#subtract算子" class="headerlink" title="subtract算子"></a>subtract算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtract</span></span>(other: <span class="type">RDD</span>[<span class="type">T</span>]): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
<p>以一个 RDD 元素为主，去除两个 RDD 中重复元素，将其他元素保留下来。求差集<br><strong>交集、并集和差集要求两个RDD数据源数据类型必须相同</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = dataRDD1.subtract(dataRDD2)</span><br></pre></td></tr></table></figure>

<h3 id="zip算子"><a href="#zip算子" class="headerlink" title="zip算子"></a>zip算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](other: <span class="type">RDD</span>[<span class="type">U</span>]): <span class="type">RDD</span>[(<span class="type">T</span>, <span class="type">U</span>)]</span><br></pre></td></tr></table></figure>
<p>将两个 RDD 中的元素，以键值对的形式进行合并。其中，键值对中的 Key 为第 1 个 RDD中的元素，Value 为第 2 个 RDD 中的相同位置的元素。<br><strong>必须保证分区数量相等，分区中数据的数量必须一致（区别于scala中zip）</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = dataRDD1.zip(dataRDD2)</span><br></pre></td></tr></table></figure>
<h2 id="Key-Value-类型"><a href="#Key-Value-类型" class="headerlink" title="Key - Value 类型"></a>Key - Value 类型</h2><p>数据的类型必须是键值元组才能使用key-value类型算子</p>
<h3 id="partitionBy算子"><a href="#partitionBy算子" class="headerlink" title="partitionBy算子"></a>partitionBy算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partitionBy</span></span>(partitioner: <span class="type">Partitioner</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)]</span><br></pre></td></tr></table></figure>
<p>spark的分区器：只有涉及到 key-value 类型的RDD才会用到分区器，因为分区是以key分区的<br>将数据按照指定 Partitioner 重新进行分区。Spark 默认的分区器是 HashPartitioner<br>如果重分区的分区器和当前 RDD 的分区器一样，不会进行操作</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] =</span><br><span class="line"> sc.makeRDD(<span class="type">Array</span>((<span class="number">1</span>,<span class="string">&quot;aaa&quot;</span>),(<span class="number">2</span>,<span class="string">&quot;bbb&quot;</span>),(<span class="number">3</span>,<span class="string">&quot;ccc&quot;</span>)),<span class="number">3</span>)</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">HashPartitioner</span></span><br><span class="line"><span class="keyword">val</span> rdd2: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] =</span><br><span class="line"> rdd.partitionBy(<span class="keyword">new</span> <span class="type">HashPartitioner</span>(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<h3 id="reduceByKey算子"><a href="#reduceByKey算子" class="headerlink" title="reduceByKey算子"></a>reduceByKey算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduceByKey</span></span>(func: (<span class="type">V</span>, <span class="type">V</span>) =&gt; <span class="type">V</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduceByKey</span></span>(func: (<span class="type">V</span>, <span class="type">V</span>) =&gt; <span class="type">V</span>, numPartitions: <span class="type">Int</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)]</span><br></pre></td></tr></table></figure>
<p>可以将数据按照相同的 Key 对 Value 进行聚合<br>按照第一个元素进行聚合后对第二个元素进行计算，若有多条数据聚合到了一起则两两进行运算，若只有一条数据不会进行后面的函数运算</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>((<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = dataRDD1.reduceByKey(_+_)</span><br><span class="line"><span class="keyword">val</span> dataRDD3 = dataRDD1.reduceByKey(_+_, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="groupByKey算子"><a href="#groupByKey算子" class="headerlink" title="groupByKey算子"></a>groupByKey算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupByKey</span></span>(): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">Iterable</span>[<span class="type">V</span>])]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupByKey</span></span>(numPartitions: <span class="type">Int</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">Iterable</span>[<span class="type">V</span>])]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupByKey</span></span>(partitioner: <span class="type">Partitioner</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">Iterable</span>[<span class="type">V</span>])]</span><br></pre></td></tr></table></figure>
<p>将数据源的数据根据 key 对 value 进行分组<br><strong>reduceByKey和groupByKey的对比</strong>：<br>&amp;nbsp;&amp;nbsp; reduce会在shuffl前进行预聚合（在分区内进行聚合），减少落盘的数据量，性能比group好<br>&amp;nbsp;&amp;nbsp; reduce包含了分组和聚合的功能，group只有聚合的功能</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 =</span><br><span class="line"> sparkContext.makeRDD(<span class="type">List</span>((<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = dataRDD1.groupByKey()</span><br><span class="line"><span class="keyword">val</span> dataRDD3 = dataRDD1.groupByKey(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD4 = dataRDD1.groupByKey(<span class="keyword">new</span> <span class="type">HashPartitioner</span>(<span class="number">2</span>))  </span><br></pre></td></tr></table></figure>

<h3 id="aggregateByKey算子"><a href="#aggregateByKey算子" class="headerlink" title="aggregateByKey算子"></a>aggregateByKey算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aggregateByKey</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](zeroValue: <span class="type">U</span>)(seqOp: (<span class="type">U</span>, <span class="type">V</span>) =&gt; <span class="type">U</span>,</span><br><span class="line"> combOp: (<span class="type">U</span>, <span class="type">U</span>) =&gt; <span class="type">U</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">U</span>)]</span><br></pre></td></tr></table></figure>
<p>取出每个分区内相同 key 的最大值然后分区间相加<br>1、 第一个参数列表中的参数表示初始值<br>2、 第二个参数列表中含有两个参数<br>2.1 第一个参数表示分区内的计算规则<br>2.2 第二个参数表示分区间的计算规则</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取出每个分区内相同 key 的最大值然后分区间相加</span></span><br><span class="line"><span class="keyword">val</span> rdd =</span><br><span class="line"> sc.makeRDD(<span class="type">List</span>(</span><br><span class="line"> (<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;a&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>),</span><br><span class="line"> (<span class="string">&quot;b&quot;</span>,<span class="number">4</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">5</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">6</span>)</span><br><span class="line"> ),<span class="number">2</span>)</span><br><span class="line"> <span class="keyword">val</span> resultRDD =</span><br><span class="line"> rdd.aggregateByKey(<span class="number">10</span>)(</span><br><span class="line"> (x, y) =&gt; math.max(x,y),</span><br><span class="line"> (x, y) =&gt; x + y</span><br><span class="line"> )</span><br></pre></td></tr></table></figure>

<h3 id="foldByKey算子"><a href="#foldByKey算子" class="headerlink" title="foldByKey算子"></a>foldByKey算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldByKey</span></span>(zeroValue: <span class="type">V</span>)(func: (<span class="type">V</span>, <span class="type">V</span>) =&gt; <span class="type">V</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)]</span><br></pre></td></tr></table></figure>
<p>当分区内计算规则和分区间计算规则相同时，aggregateByKey 就可以简化为 foldByKey</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>((<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = dataRDD1.foldByKey(<span class="number">0</span>)(_+_)</span><br></pre></td></tr></table></figure>

<h3 id="combineByKey算子"><a href="#combineByKey算子" class="headerlink" title="combineByKey算子"></a>combineByKey算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combineByKey</span></span>[<span class="type">C</span>](</span><br><span class="line"> createCombiner: <span class="type">V</span> =&gt; <span class="type">C</span>,</span><br><span class="line"> mergeValue: (<span class="type">C</span>, <span class="type">V</span>) =&gt; <span class="type">C</span>,</span><br><span class="line"> mergeCombiners: (<span class="type">C</span>, <span class="type">C</span>) =&gt; <span class="type">C</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">C</span>)]</span><br></pre></td></tr></table></figure>
<p>最通用的对 key-value 型 rdd 进行聚集操作的聚集函数（aggregation function）。类似于aggregate()，combineByKey()允许用户返回值的类型与输入不一致。<br><strong>reduceByKey、foldByKey、aggregateByKey、combineByKey 的区别</strong>:<br>&amp;nbsp;reduceByKey: 相同 key 的第一个数据不进行任何计算，分区内和分区间计算规则相同<br>&amp;nbsp;FoldByKey: 相同 key 的第一个数据和初始值进行分区内计算，分区内和分区间计算规则相同<br>&amp;nbsp;AggregateByKey：相同 key 的第一个数据和初始值进行分区内计算，分区内和分区间计算规则可以不相同<br>&amp;nbsp;CombineByKey:当计算时，发现数据结构不满足要求时，可以让第一个数据转换结构。分区内和分区间计算规则不相同<br><strong>本质上四个算子都是对combineByKeyWithClassTag方法的封装</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将数据 List((&quot;a&quot;, 88), (&quot;b&quot;, 95), (&quot;a&quot;, 91), (&quot;b&quot;, 93), (&quot;a&quot;, 95), (&quot;b&quot;, 98))求每个 key 的平均值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> list: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">List</span>((<span class="string">&quot;a&quot;</span>, <span class="number">88</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">95</span>), (<span class="string">&quot;a&quot;</span>, <span class="number">91</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">93</span>),</span><br><span class="line">(<span class="string">&quot;a&quot;</span>, <span class="number">95</span>), (<span class="string">&quot;b&quot;</span>, <span class="number">98</span>))</span><br><span class="line"><span class="keyword">val</span> input: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = sc.makeRDD(list, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> combineRdd: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>))] = input.combineByKey(</span><br><span class="line"> (_, <span class="number">1</span>),</span><br><span class="line"> (acc: (<span class="type">Int</span>, <span class="type">Int</span>), v) =&gt; (acc._1 + v, acc._2 + <span class="number">1</span>),</span><br><span class="line"> (acc1: (<span class="type">Int</span>, <span class="type">Int</span>), acc2: (<span class="type">Int</span>, <span class="type">Int</span>)) =&gt; (acc1._1 + acc2._1, acc1._2 + acc2._2)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="sortByKey算子"><a href="#sortByKey算子" class="headerlink" title="sortByKey算子"></a>sortByKey算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortByKey</span></span>(ascending: <span class="type">Boolean</span> = <span class="literal">true</span>, numPartitions: <span class="type">Int</span> = self.partitions.length)</span><br><span class="line"> : <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)]</span><br></pre></td></tr></table></figure>
<p>在一个(K,V)的 RDD 上调用，K 必须实现 Ordered 接口(特质)(即键必须能够进行排序)，返回一个按照 key 进行排序的</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>((<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> sortRDD1: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = dataRDD1.sortByKey(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">val</span> sortRDD1: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = dataRDD1.sortByKey(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<h3 id="join算子"><a href="#join算子" class="headerlink" title="join算子"></a>join算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join</span></span>[<span class="type">W</span>](other: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W</span>)]): <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">V</span>, <span class="type">W</span>))]</span><br></pre></td></tr></table></figure>
<p>在类型为(K,V)和(K,W)的 RDD 上调用，返回一个相同 key 对应的所有元素连接在一起的(K,(V,W))的 RDD<br>如果数据中有多个相同的key，会一次进行匹配，类似于笛卡尔乘积（得到多个二元组，而不是一个多元组），数据量会呈几何增长，有内存风险</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = sc.makeRDD(<span class="type">Array</span>((<span class="number">1</span>, <span class="string">&quot;a&quot;</span>), (<span class="number">2</span>, <span class="string">&quot;b&quot;</span>), (<span class="number">3</span>, <span class="string">&quot;c&quot;</span>)))</span><br><span class="line"><span class="keyword">val</span> rdd1: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = sc.makeRDD(<span class="type">Array</span>((<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)))</span><br><span class="line">rdd.join(rdd1)</span><br></pre></td></tr></table></figure>

<h3 id="leftOuterJoin算子"><a href="#leftOuterJoin算子" class="headerlink" title="leftOuterJoin算子"></a>leftOuterJoin算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leftOuterJoin</span></span>[<span class="type">W</span>](other: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W</span>)]): <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">V</span>, <span class="type">Option</span>[<span class="type">W</span>]))]</span><br></pre></td></tr></table></figure>
<p>类似于 SQL 语句的左外连接</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>((<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = sparkContext.makeRDD(<span class="type">List</span>((<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;b&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Option</span>[<span class="type">Int</span>]))] = dataRDD1.leftOuterJoin(dataRDD2)</span><br></pre></td></tr></table></figure>

<h3 id="cogroup算子"><a href="#cogroup算子" class="headerlink" title="cogroup算子"></a>cogroup算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cogroup</span></span>[<span class="type">W</span>](other: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W</span>)]): <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">Iterable</span>[<span class="type">V</span>], <span class="type">Iterable</span>[<span class="type">W</span>]))]</span><br></pre></td></tr></table></figure>
<p>在类型为(K,V)和(K,W)的 RDD 上调用，返回一个(K,(Iterable<V>,Iterable<W>))类型的 RDD<br>cogroup &#x3D; connect+group<br>不理解可以看函数签名的返回值类型，第一个集合是RDD1的值，第二个集合中是RDD2的值，可能为空也可能有多个</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>((<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;a&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = sparkContext.makeRDD(<span class="type">List</span>((<span class="string">&quot;a&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">2</span>),(<span class="string">&quot;c&quot;</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> value: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Iterable</span>[<span class="type">Int</span>], <span class="type">Iterable</span>[<span class="type">Int</span>]))] =</span><br><span class="line">dataRDD1.cogroup(dataRDD2)</span><br></pre></td></tr></table></figure>

<h1 id="行动算子"><a href="#行动算子" class="headerlink" title="行动算子"></a>行动算子</h1><p>行动算子会触发作业的执行<br>底层代码调用的是环境对象的runJob方法<br>底层代码会创建ActionJob，并提交执行</p>
<h3 id="reduce算子"><a href="#reduce算子" class="headerlink" title="reduce算子"></a>reduce算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce</span></span>(f: (<span class="type">T</span>, <span class="type">T</span>) =&gt; <span class="type">T</span>): <span class="type">T</span></span><br></pre></td></tr></table></figure>
<p>聚集 RDD 中的所有元素，先聚合分区内数据，再聚合分区间数据<br><strong>注意与reduceByKey进行区分</strong> </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment">// 聚合数据</span></span><br><span class="line"><span class="keyword">val</span> reduceResult: <span class="type">Int</span> = rdd.reduce(_+_)<span class="comment">// 返回值为Int类型</span></span><br></pre></td></tr></table></figure>

<h3 id="collect算子"><a href="#collect算子" class="headerlink" title="collect算子"></a>collect算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collect</span></span>(): <span class="type">Array</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
<p>在驱动程序中，以数组 Array 的形式返回数据集的所有元素</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment">// 收集数据到 Driver</span></span><br><span class="line">rdd.collect().foreach(println)</span><br></pre></td></tr></table></figure>

<h3 id="count算子"><a href="#count算子" class="headerlink" title="count算子"></a>count算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span></span>(): <span class="type">Long</span></span><br></pre></td></tr></table></figure>
<p>返回 RDD 中元素的个数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment">// 返回 RDD 中元素的个数</span></span><br><span class="line"><span class="keyword">val</span> countResult: <span class="type">Long</span> = rdd.count()</span><br></pre></td></tr></table></figure>

<h3 id="first算子"><a href="#first算子" class="headerlink" title="first算子"></a>first算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first</span></span>(): <span class="type">T</span></span><br></pre></td></tr></table></figure>
<p>返回 RDD 中的第一个元素</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment">// 返回 RDD 中元素的个数</span></span><br><span class="line"><span class="keyword">val</span> firstResult: <span class="type">Int</span> = rdd.first()</span><br><span class="line">println(firstResult)</span><br></pre></td></tr></table></figure>

<h3 id="take算子"><a href="#take算子" class="headerlink" title="take算子"></a>take算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">take</span></span>(num: <span class="type">Int</span>): <span class="type">Array</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
<p>返回一个由 RDD 的前 n 个元素组成的数组</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment">// 返回 RDD 中元素的个数</span></span><br><span class="line"><span class="keyword">val</span> takeResult: <span class="type">Array</span>[<span class="type">Int</span>] = rdd.take(<span class="number">2</span>)</span><br><span class="line">println(takeResult.mkString(<span class="string">&quot;,&quot;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="takeOrdered算子"><a href="#takeOrdered算子" class="headerlink" title="takeOrdered算子"></a>takeOrdered算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeOrdered</span></span>(num: <span class="type">Int</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>]): <span class="type">Array</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
<p>返回该 RDD 排序后的前 n 个元素组成的数组</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment">// 返回 RDD 中元素的个数</span></span><br><span class="line"><span class="keyword">val</span> result: <span class="type">Array</span>[<span class="type">Int</span>] = rdd.takeOrdered(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="aggregate算子"><a href="#aggregate算子" class="headerlink" title="aggregate算子"></a>aggregate算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aggregate</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](zeroValue: <span class="type">U</span>)(</span><br><span class="line">   seqOp: (<span class="type">U</span>, <span class="type">T</span>) =&gt; <span class="type">U</span>, combOp: (<span class="type">U</span>, <span class="type">U</span>) =&gt; <span class="type">U</span>)</span><br><span class="line">   : <span class="type">U</span></span><br></pre></td></tr></table></figure>
<p>分区的数据通过初始值和分区内的数据进行聚合，然后再和初始值进行分区间的数据聚合<br><strong>区别于aggregateByKey算子</strong>，aggregateByKey得到新的RDD，aggregate直接得到结果<br><strong>注意</strong>：aggregateByKey的初始值只会参与分区内的计算，aggregate不仅只进行分区内的计算，还会进行分区之间的计算！</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), <span class="number">8</span>)</span><br><span class="line"><span class="comment">// 将该 RDD 所有元素相加得到结果</span></span><br><span class="line"><span class="comment">//val result: Int = rdd.aggregate(0)(_ + _, _ + _)</span></span><br><span class="line"><span class="keyword">val</span> result: <span class="type">Int</span> = rdd.aggregate(<span class="number">10</span>)(_ + _, _ + _)</span><br></pre></td></tr></table></figure>

<h3 id="fold算子"><a href="#fold算子" class="headerlink" title="fold算子"></a>fold算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>(zeroValue: <span class="type">T</span>)(op: (<span class="type">T</span>, <span class="type">T</span>) =&gt; <span class="type">T</span>): <span class="type">T</span> </span><br></pre></td></tr></table></figure>
<p>折叠操作，aggregate 的简化版操作，分区内和分区间的操作相同</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">val</span> foldResult: <span class="type">Int</span> = rdd.fold(<span class="number">0</span>)(_+_)</span><br></pre></td></tr></table></figure>

<h3 id="countByKey算子"><a href="#countByKey算子" class="headerlink" title="countByKey算子"></a>countByKey算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countByKey</span></span>(): <span class="type">Map</span>[<span class="type">K</span>, <span class="type">Long</span>]</span><br></pre></td></tr></table></figure>
<p>统计每种 key 的个数<br>与该算子类似的还有countByValue算子，统计值的个数，用于单值类型RDD </p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = sc.makeRDD(<span class="type">List</span>((<span class="number">1</span>, <span class="string">&quot;a&quot;</span>), (<span class="number">1</span>, <span class="string">&quot;a&quot;</span>), (<span class="number">1</span>, <span class="string">&quot;a&quot;</span>), (<span class="number">2</span>,</span><br><span class="line"><span class="string">&quot;b&quot;</span>), (<span class="number">3</span>, <span class="string">&quot;c&quot;</span>), (<span class="number">3</span>, <span class="string">&quot;c&quot;</span>)))</span><br><span class="line"><span class="comment">// 统计每种 key 的个数</span></span><br><span class="line"><span class="keyword">val</span> result: collection.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Long</span>] = rdd.countByKey()</span><br></pre></td></tr></table></figure>

<h3 id="save相关算子"><a href="#save相关算子" class="headerlink" title="save相关算子"></a>save相关算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveAsTextFile</span></span>(path: <span class="type">String</span>): <span class="type">Unit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveAsObjectFile</span></span>(path: <span class="type">String</span>): <span class="type">Unit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveAsSequenceFile</span></span>(</span><br><span class="line"> path: <span class="type">String</span>,</span><br><span class="line"> codec: <span class="type">Option</span>[<span class="type">Class</span>[_ &lt;: <span class="type">CompressionCodec</span>]] = <span class="type">None</span>): <span class="type">Unit</span></span><br></pre></td></tr></table></figure>
<p>将数据保存到不同格式的文件中<br><strong>saveAsSequenceFile必须是键值类型RDD</strong></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存成 Text 文件</span></span><br><span class="line">rdd.saveAsTextFile(<span class="string">&quot;output&quot;</span>)</span><br><span class="line"><span class="comment">// 序列化成对象保存到文件</span></span><br><span class="line">rdd.saveAsObjectFile(<span class="string">&quot;output1&quot;</span>)</span><br><span class="line"><span class="comment">// 保存成 Sequencefile 文件</span></span><br><span class="line">rdd.map((_,<span class="number">1</span>)).saveAsSequenceFile(<span class="string">&quot;output2&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="foreach算子"><a href="#foreach算子" class="headerlink" title="foreach算子"></a>foreach算子</h3><p>函数签名：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>(f: <span class="type">T</span> =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = withScope &#123;</span><br><span class="line"> <span class="keyword">val</span> cleanF = sc.clean(f)</span><br><span class="line"> sc.runJob(<span class="keyword">this</span>, (iter: <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; iter.foreach(cleanF))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分布式遍历 RDD 中的每一个元素，调用指定函数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="comment">// 这里的foreach是在driver端的内存中进行打印的</span></span><br><span class="line">rdd.collect().foreach(println)    <span class="comment">// 1 2 3 4</span></span><br><span class="line">println(<span class="string">&quot;*******************&quot;</span>)</span><br><span class="line"><span class="comment">// 这里的foreach是在excutor端内存中进行打印的</span></span><br><span class="line">rdd.foreach(println)    <span class="comment">// 2 1 3 4(无序)</span></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>寒假学习</category>
      </categories>
      <tags>
        <tag>spark</tag>
        <tag>学习</tag>
        <tag>大数据系统</tag>
      </tags>
  </entry>
  <entry>
    <title>测试文章</title>
    <url>/2022/02/07/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/</url>
    <content><![CDATA[<h1 id="Hello-my-friend"><a href="#Hello-my-friend" class="headerlink" title="Hello my friend!"></a>Hello my friend!</h1><!-- <img src="/2022/02/07/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/test.png" class="" title="图片引用方法一"> -->
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>游戏</tag>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/02/07/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
